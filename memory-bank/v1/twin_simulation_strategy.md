# Twin Simulation & Autonomy Strategy (v1+)

This document outlines the strategy for representing and storing actions and content generated by a user's Digital Twin, particularly as the system evolves towards greater twin autonomy beyond the v0 prototype.

## Context: Twin Representation in v0

In the initial prototype (v0), the "Digital Twin" is primarily a conceptual role fulfilled by the Canvas Agent system (Developer A). This agent uses the TwinCore backend API (Developer B) to retrieve relevant data from a user's memory store (`/v1/users/{user_id}/private_memory`, `/v1/user/{user_id}/context`, `/v1/user/{user_id}/preferences`, etc.) and then performs LLM-based synthesis to generate responses or simulate the user's perspective.

Crucially, in v0:
*   There is **no distinct `Twin` entity** stored within the TwinCore backend's databases (Qdrant, Neo4j).
*   Actions recorded are either direct user actions (messages sent, documents uploaded) or user queries *to* the simulated twin (ingested via `POST /v1/users/{user_id}/private_memory` and marked with `is_twin_interaction: true`).
*   Twin *responses* generated by the Canvas Agent are **not** stored back into the TwinCore memory store.

This model keeps the v0 backend focused on data storage and retrieval, aligning with the `separationStrategy.md`.

## Challenge: Representing Twin-Generated Content & Actions (v1+)

As the system evolves, we anticipate scenarios where:
1.  The twin's side of a conversation with the user needs to be persisted for history and context.
2.  The twin might perform autonomous actions *on behalf of* the user (e.g., sending a summary message, casting a vote based on learned preferences, drafting a document section).

This requires a clear way to distinguish between content/actions directly from the user versus those generated/performed by their twin simulation.

## Proposed Solution: Attribution via `created_by_type`

Instead of introducing a complex `Twin` entity node in Neo4j prematurely, we propose using an attribution flag/property to mark the origin of content and actions.

**1. Introduce `created_by_type` Attribute:**
   *   **Qdrant:** Add a new field to relevant Qdrant payloads (e.g., for points representing messages, document chunks):
      ```json
      "created_by_type": "string ('user' | 'twin')" // Default: 'user'
      ```
   *   **Neo4j:** Add a new property to relevant action-oriented relationships (e.g., `AUTHORED`, `UPLOADED`, `CAST_VOTE`, `STATED`):
      ```cypher
      (u:User)-[:AUTHORED {timestamp: ..., created_by_type: 'twin'}]->(m:Message)
      ```

**2. Implementation Steps (v1):**
   *   **Schema Update:** Formally add these fields/properties to the definitions in `dataSchema.md`.
   *   **Ingestion API Update:** Modify relevant ingestion endpoints (`POST /v1/ingest/message`, `POST /v1/ingest/document`, potentially new endpoints for votes etc.) to accept an optional `created_by_type` parameter in the request body. If omitted, it defaults to `'user'`.
   *   **DAL Update:** Update the Data Access Layer (DAL) methods in `twincore_backend` to correctly store this `created_by_type` value in both Qdrant payloads and Neo4j relationship properties during ingestion.
   *   **Canvas Agent (Dev A) Responsibility:** When the Canvas Agent system generates content *as the twin* (e.g., a response in a twin chat, an autonomous message), it **must** call the appropriate TwinCore ingestion endpoint and explicitly provide `created_by_type: 'twin'` in the request.

**3. Storing Twin-Generated Content:**
   *   **Twin Responses:** When Dev A's system generates a response from the twin to the user, it should call `POST /v1/ingest/message` with the response text, the relevant context (`user_id`, `session_id`, etc.), and `created_by_type: 'twin'`. This ensures the full conversation history is stored.
   *   **Twin Autonomous Actions:** When the twin performs an action (sends a message, contributes to a doc, casts a vote), the record of that action ingested into TwinCore must include `created_by_type: 'twin'`.

**4. Filtering & Auditing:**
   *   This approach allows for easy filtering and auditing. The Canvas Agent (Dev A) can query TwinCore retrieval endpoints and specifically filter results based on the `created_by_type` property.
   *   **Example:** To show a user everything their twin has done autonomously, Dev A could potentially query endpoints with a filter like `metadata.created_by_type == 'twin'` (syntax depends on specific endpoint implementation). This provides necessary transparency.

## Benefits of this Approach

*   **Minimal Schema Disruption:** Avoids adding a new core entity (`Twin` node) until potentially much later, simplifying the v1 transition.
*   **Clear Attribution:** Provides an unambiguous way to track the origin of any piece of content or recorded action.
*   **Maintains User Centricity:** Actions are still fundamentally linked to the `User` node whose preferences/data the twin represents.
*   **Enables Filtering:** Allows client applications (like the Canvas) to easily differentiate and display user vs. twin activity.
*   **Scalability:** Seems more scalable initially than managing complex `Twin` entities and their relationships.

## Conclusion for v0

No immediate changes are required for the v0 prototype based on this future planning. The current architecture, where Dev A simulates the twin using Dev B's retrieval APIs, remains sufficient. This document serves as the plan for incorporating more advanced twin representation in future versions. 